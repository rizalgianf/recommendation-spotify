# -*- coding: utf-8 -*-
"""rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yzaomoghi6hLD0b7IpYk9-8-087t--pa

## Import Library
"""

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import hstack, csr_matrix

"""## Load Data Set

1. Membaca file dataset CSV bernama `top_10000_1950-now.csv` ke dalam sebuah DataFrame pandas dengan nama `df`. Sumber : https://www.kaggle.com/datasets/joebeachcapital/top-10000-spotify-songs-1960-now
2. Menampilkan 5 baris pertama dari DataFrame tersebut menggunakan `df.head()`, sehingga kita bisa melihat contoh data yang dimuat dari file tersebut.

Langkah ini penting untuk memastikan data berhasil dimuat dan memahami struktur kolom serta beberapa nilai awal pada dataset.
"""

# Load dataset
df = pd.read_csv('top_10000_1950-now.csv')
df.head()

"""### Insight Data Awal Spotify Top 10.000 Songs

1. **Keberagaman Tahun Rilis**  
    Lagu-lagu dalam dataset berasal dari berbagai dekade, mulai dari tahun 1970-an hingga 2019. Hal ini menunjukkan dataset mencakup lagu-lagu lintas generasi, sehingga cocok untuk analisis tren musik jangka panjang.

2. **Genre dan Artis Beragam**  
    Kolom `Artist Genres` dan `Artist Name(s)` memperlihatkan keberagaman genre dan artis, mulai dari pop, rock, electropop, hingga soft rock. Ini menandakan dataset dapat digunakan untuk analisis preferensi genre dan popularitas artis.

3. **Fitur Audio Lengkap**  
    Dataset menyediakan fitur audio seperti `Danceability`, `Energy`, `Speechiness`, `Acousticness`, `Instrumentalness`, `Liveness`, `Valence`, dan `Tempo`. Fitur-fitur ini sangat bermanfaat untuk analisis karakteristik lagu, pembuatan rekomendasi, dan segmentasi musik.

4. **Popularitas Lagu**  
    Terdapat kolom `Popularity` yang dapat digunakan untuk mengidentifikasi lagu-lagu hits dan membandingkan karakteristik lagu populer dengan yang kurang populer.

5. **Kelengkapan Data**  
    Beberapa kolom seperti `Album Genres` memiliki banyak nilai kosong (NaN), namun fitur utama seperti nama lagu, artis, genre, dan fitur audio relatif lengkap setelah proses cleaning.

6. **Potensi Analisis**  
    Dataset ini sangat potensial untuk:
    - Analisis tren musik berdasarkan waktu.
    - Rekomendasi lagu berbasis kemiripan fitur audio dan genre.
    - Analisis popularitas berdasarkan genre, artis, atau fitur audio tertentu.
    - Visualisasi distribusi fitur audio untuk memahami karakteristik lagu-lagu populer.

7. **Contoh Lagu**  
    Lagu-lagu seperti "Fader" (The Temper Trap), "Sherry" (Frankie Valli & The Four Seasons), dan "I Took A Pill In Ibiza - Seeb Remix" (Mike Posner, Seeb) menunjukkan adanya kombinasi antara lagu klasik dan modern dalam dataset.

**Kesimpulan:**  
Dataset ini sangat kaya dan representatif untuk analisis musik populer lintas waktu, genre, dan artis, serta sangat mendukung pengembangan sistem rekomendasi musik berbasis fitur audio dan metadata.

### Penjelasan Kode Pemeriksaan DataFrame

- `print("Jumlah baris:", df.shape[0])`  
    Menampilkan jumlah baris (data/record) pada DataFrame `df`. `df.shape[0]` mengembalikan jumlah baris.

- `print("Jumlah kolom:", df.shape[1])`  
    Menampilkan jumlah kolom pada DataFrame `df`. `df.shape[1]` mengembalikan jumlah kolom.

- `df.info()`  
    Menampilkan ringkasan struktur DataFrame, termasuk jumlah baris, nama kolom, jumlah non-null per kolom, tipe data setiap kolom, dan penggunaan memori.

- `print(df.isnull().sum())`  
    Menampilkan jumlah nilai kosong (missing value/NaN) pada setiap kolom di DataFrame. Fungsi `df.isnull().sum()` menghitung total nilai kosong per kolom, sehingga memudahkan identifikasi kolom yang perlu dibersihkan.
"""

print("Jumlah baris:", df.shape[0])
print("Jumlah kolom:", df.shape[1])
df.info()
print(df.isnull().sum())

"""- Sebagian besar kolom memiliki data yang cukup lengkap, namun terdapat beberapa kolom dengan nilai kosong (missing values):
      - **Kolom `Album Genres`** sepenuhnya kosong (10.000 nilai kosong).
      - **Kolom `Artist Genres`** memiliki 551 nilai kosong.
      - **Kolom `Track Preview URL`** memiliki 63 nilai kosong.
      - Kolom numerik seperti `Danceability`, `Energy`, `Key`, `Loudness`, `Mode`, `Speechiness`, `Acousticness`, `Instrumentalness`, `Liveness`, `Valence`, `Tempo`, dan `Time Signature` memiliki masing-masing 5 nilai kosong.
      - Kolom metadata seperti `Label` dan `Copyrights` memiliki masing-masing 7 dan 23 nilai kosong.

# Drop baris dengan missing value pada fitur penting
"""

# Drop baris dengan missing value pada fitur penting
df_clean = df.dropna(subset=[
    'Track Name', 'Artist Name(s)', 'Artist Genres',
    'Danceability', 'Energy', 'Speechiness', 'Acousticness',
    'Instrumentalness', 'Liveness', 'Valence', 'Tempo', 'Popularity'
]).reset_index(drop=True)
print("Setelah cleaning:", df_clean.shape)

"""# Gabungkan fitur teks (genre dan artis)"""

# Gabungkan fitur teks (genre dan artis)
df_clean['combined_features'] = (
    df_clean['Artist Genres'].astype(str) + ' ' +
    df_clean['Artist Name(s)'].astype(str)
)

"""### Penjelasan Kode: Gabungkan Fitur Teks (Genre dan Artis)

Kode ini bertujuan untuk membuat kolom baru bernama `combined_features` dalam DataFrame `df_clean`. Kolom ini menggabungkan informasi dari dua kolom teks, yaitu `Artist Genres` dan `Artist Name(s)`. Berikut penjelasan langkah-langkahnya:

1. **`df_clean['Artist Genres'].astype(str)`**  
    Mengonversi nilai dalam kolom `Artist Genres` menjadi tipe data string. Hal ini dilakukan untuk memastikan semua nilai dapat digabungkan, termasuk nilai NaN (akan diubah menjadi string `'nan'`).

2. **`df_clean['Artist Name(s)'].astype(str)`**  
    Mengonversi nilai dalam kolom `Artist Name(s)` menjadi tipe data string, dengan alasan yang sama seperti langkah sebelumnya.

3. **Penggabungan dengan Operator `+`**  
    Menggabungkan string dari kolom `Artist Genres` dan `Artist Name(s)` dengan menambahkan spasi (`' '`) di antara keduanya. Hasilnya adalah string gabungan yang berisi genre dan nama artis.

4. **Hasil Akhir**  
    Kolom baru `combined_features` akan berisi teks gabungan dari genre dan nama artis, yang dapat digunakan untuk analisis berbasis teks, seperti pembuatan matriks TF-IDF untuk sistem rekomendasi.

**Contoh Hasil:**
- Jika `Artist Genres` = `"pop, uk pop"` dan `Artist Name(s)` = `"Ed Sheeran"`, maka `combined_features` = `"pop, uk pop Ed Sheeran"`.
- Jika `Artist Genres` = `NaN` dan `Artist Name(s)` = `"Adele"`, maka `combined_features` = `"nan Adele"`.
```

# Pilih fitur numerik
"""

# Pilih fitur numerik
num_features = [
    'Danceability','Energy','Speechiness','Acousticness',
    'Instrumentalness','Liveness','Valence','Tempo','Popularity'
]
# Normalisasi fitur numerik
scaler = MinMaxScaler()
df_num_scaled = scaler.fit_transform(df_clean[num_features])

"""### Penjelasan Kode: Pilih dan Normalisasi Fitur Numerik

1. **`num_features`**  
    - Variabel `num_features` adalah daftar nama kolom yang berisi fitur numerik dari DataFrame `df_clean`. Fitur-fitur ini dipilih karena relevan untuk analisis atau pemrosesan lebih lanjut.
    - Fitur yang dipilih:
      - `Danceability`: Tingkat kelayakan lagu untuk menari.
      - `Energy`: Tingkat energi lagu.
      - `Speechiness`: Proporsi elemen vokal dalam lagu.
      - `Acousticness`: Kemungkinan lagu bersifat akustik.
      - `Instrumentalness`: Tingkat instrumental dalam lagu.
      - `Liveness`: Kemungkinan lagu direkam secara langsung.
      - `Valence`: Tingkat kebahagiaan atau kesedihan lagu.
      - `Tempo`: Kecepatan lagu dalam BPM (beats per minute).
      - `Popularity`: Popularitas lagu berdasarkan Spotify.

2. **`scaler = MinMaxScaler()`**  
    - Membuat objek `MinMaxScaler` dari library `sklearn.preprocessing`.
    - `MinMaxScaler` digunakan untuk normalisasi data, yaitu mengubah nilai fitur ke dalam rentang [0, 1]. Hal ini dilakukan agar semua fitur memiliki skala yang sama, sehingga tidak ada fitur yang mendominasi analisis atau model.

3. **`df_clean[num_features]`**  
    - Mengambil subset DataFrame `df_clean` yang hanya berisi kolom-kolom yang ada di `num_features`.

4. **`scaler.fit_transform(df_clean[num_features])`**  
    - `fit_transform()` melakukan dua hal:
      - **`fit`**: Menghitung nilai minimum dan maksimum dari setiap kolom dalam `num_features`.
      - **`transform`**: Mengubah nilai setiap kolom ke dalam rentang [0, 1] berdasarkan nilai minimum dan maksimum yang telah dihitung.
    - Hasilnya adalah array numpy (`df_num_scaled`) yang berisi nilai-nilai fitur numerik yang telah dinormalisasi.

5. **`df_num_scaled`**  
    - Variabel ini menyimpan hasil normalisasi dalam bentuk array numpy. Array ini dapat digunakan untuk analisis lebih lanjut, seperti pembuatan matriks fitur gabungan atau input ke model machine learning.

### Contoh:
Jika nilai awal kolom `Danceability` adalah [0.5, 0.7, 0.9], maka setelah normalisasi dengan `MinMaxScaler`, nilai tersebut akan diubah menjadi [0.0, 0.5, 1.0] (dengan asumsi 0.5 adalah nilai minimum dan 0.9 adalah nilai maksimum).

# Gabungkan fitur teks dan numerik
"""

# Create TF-IDF vectorizer for text features
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df_clean['combined_features'])

# Gabungkan fitur teks dan numerik
combined_matrix = hstack([tfidf_matrix, df_num_scaled])
combined_matrix = csr_matrix(combined_matrix)

"""### Penjelasan Kode: Gabungkan Fitur Teks dan Numerik

1. **TF-IDF Vectorization pada Fitur Teks**
  - `tfidf = TfidfVectorizer(stop_words='english')`  
    Membuat objek TF-IDF vectorizer untuk mengubah data teks menjadi representasi numerik, dengan menghilangkan stopwords bahasa Inggris.
  - `tfidf_matrix = tfidf.fit_transform(df_clean['combined_features'])`  
    Mengubah kolom `combined_features` (gabungan genre dan nama artis) menjadi matriks TF-IDF. Setiap lagu direpresentasikan sebagai vektor berdasarkan kata-kata unik yang muncul di seluruh dataset.

2. **Penggabungan Fitur Teks dan Numerik**
  - `combined_matrix = hstack([tfidf_matrix, df_num_scaled])`  
    Menggabungkan matriks TF-IDF (fitur teks) dengan array hasil normalisasi fitur numerik (`df_num_scaled`) secara horizontal, sehingga setiap lagu memiliki representasi fitur gabungan (teks + numerik).
  - `combined_matrix = csr_matrix(combined_matrix)`  
    Mengubah hasil gabungan menjadi format sparse matrix (Compressed Sparse Row) agar efisien dalam penyimpanan dan komputasi, terutama untuk data berdimensi besar.

**Kesimpulan:**  
Kode ini menghasilkan matriks fitur gabungan yang siap digunakan untuk menghitung kemiripan antar lagu pada sistem rekomendasi berbasis content-based filtering.
"""

def recommend(track_name, top_n=5):
    idx = df_clean[df_clean['Track Name'].str.lower() == track_name.lower()].index
    if len(idx) == 0:
        return "Track tidak ditemukan."
    idx = idx[0]
    sim_scores = cosine_similarity(combined_matrix[idx], combined_matrix).flatten()
    sim_indices = sim_scores.argsort()[-top_n-1:-1][::-1]
    return df_clean.iloc[sim_indices][['Track Name', 'Artist Name(s)', 'Artist Genres']]

"""## Sistem Rekomendasi Musik Berbasis Content-Based Filtering

Sistem rekomendasi ini bekerja dengan menggunakan teknik Content-Based Filtering untuk merekomendasikan lagu-lagu serupa berdasarkan karakteristik konten lagu. Berikut penjelasan cara kerjanya:

1. **Pencarian Lagu**  
    Fungsi `recommend()` mencari lagu dalam dataset berdasarkan nama lagu yang dimasukkan pengguna.

2. **Perhitungan Kesamaan**  
    Setelah lagu ditemukan, sistem menghitung skor kesamaan antara lagu tersebut dengan semua lagu lain dalam dataset menggunakan cosine similarity.

3. **Pemilihan Rekomendasi**  
    Sistem memilih lagu-lagu dengan skor kesamaan tertinggi sebagai rekomendasi, dengan jumlah sesuai parameter `top_n`.

4. **Hasil Rekomendasi**  
    Output berupa dataframe yang menampilkan informasi lagu-lagu yang direkomendasikan, meliputi judul lagu, nama artis, dan genre.

Fitur yang digunakan mencakup kombinasi fitur teks (genre dan nama artis) dan fitur audio (seperti danceability, energy, speechiness, dll) yang telah dinormalisasi untuk menghasilkan rekomendasi yang akurat berdasarkan karakteristik musik.
"""

# Cek genre/artis dari hasil rekomendasi
hasil = recommend('Shape of You')
print(hasil)

"""## Insight Hasil Rekomendasi untuk Lagu "Shape of You"

### Analisis Rekomendasi
1. **Kesamaan Artis**: Sistem merekomendasikan 5 lagu yang seluruhnya dari artis yang sama, yaitu Ed Sheeran. Ini menunjukkan bahwa model mengidentifikasi kesamaan creator sebagai faktor signifikan dalam preferensi musik.

2. **Konsistensi Genre**: Semua lagu yang direkomendasikan memiliki genre yang identik: "pop, singer-songwriter pop, uk pop". Hal ini menandakan sistem berhasil mengidentifikasi karakteristik genre yang relevan dengan lagu input.

3. **Variasi Lagu**: Sistem merekomendasikan berbagai lagu dari Ed Sheeran dengan judul berbeda ("Shivers", "Eyes Closed", "New York", "Small Bump", "Sing"), menunjukkan keragaman dalam katalog musik artis tersebut.

4. **Efektivitas Content-Based Filtering**: Hasil ini memperlihatkan bahwa sistem rekomendasi berbasis konten bekerja dengan baik dalam mengidentifikasi kesamaan berdasarkan metadata dan fitur audio.

5. **Potensi Pengembangan**: Meskipun rekomendasi akurat dari segi kesamaan artis dan genre, sistem mungkin dapat ditingkatkan untuk memberikan variasi artis yang lebih beragam namun tetap mempertahankan kesamaan karakteristik musik.
"""

# Evaluasi sistem rekomendasi
def evaluate_recommendations(sample_tracks, top_n=5):
    # Metrik evaluasi
    results = {
        'track': [],
        'artist_diversity': [],
        'genre_diversity': [],
        'avg_popularity': [],
        'avg_similarity': []
    }

    for track in sample_tracks:
        # Mendapatkan rekomendasi
        recommendations = recommend(track, top_n)
        if isinstance(recommendations, str):  # Jika track tidak ditemukan
            continue

        # Mendapatkan indeks lagu asli
        original_idx = df_clean[df_clean['Track Name'].str.lower() == track.lower()].index[0]

        # Menghitung keunikan artis dan genre
        unique_artists = recommendations['Artist Name(s)'].nunique()
        artist_diversity = unique_artists / len(recommendations)

        # Genre diversity (split genre dan hitung keunikan)
        all_genres = []
        for genre_str in recommendations['Artist Genres']:
            genres = [g.strip() for g in str(genre_str).split(',')]
            all_genres.extend(genres)
        unique_genres = len(set(all_genres))
        genre_diversity = unique_genres / len(all_genres) if all_genres else 0

        # Rata-rata popularitas (asumsi ada kolom Popularity)
        rec_indices = recommendations.index
        avg_popularity = df_clean.loc[rec_indices, 'Popularity'].mean()

        # Rata-rata similarity dengan lagu asli
        similarities = cosine_similarity(combined_matrix[original_idx], combined_matrix[rec_indices]).flatten()
        avg_similarity = similarities.mean()

        # Menyimpan hasil
        results['track'].append(track)
        results['artist_diversity'].append(artist_diversity)
        results['genre_diversity'].append(genre_diversity)
        results['avg_popularity'].append(avg_popularity)
        results['avg_similarity'].append(avg_similarity)

    # Membuat DataFrame hasil evaluasi
    eval_df = pd.DataFrame(results)
    return eval_df

# Sampel lagu untuk evaluasi
sample_tracks = ['Shape of You', 'Bohemian Rhapsody', 'Billie Jean', 'Bad Guy', 'Watermelon Sugar']
evaluation_results = evaluate_recommendations(sample_tracks)

# Menampilkan hasil evaluasi
print("Hasil Evaluasi Sistem Rekomendasi:")
print(evaluation_results)

# Menghitung rata-rata metrik
print("\nRata-rata Metrik:")
print(f"Artist Diversity: {evaluation_results['artist_diversity'].mean():.2f}")
print(f"Genre Diversity: {evaluation_results['genre_diversity'].mean():.2f}")
print(f"Average Popularity: {evaluation_results['avg_popularity'].mean():.2f}")
print(f"Average Similarity: {evaluation_results['avg_similarity'].mean():.2f}")

# Visualisasi hasil
import matplotlib.pyplot as plt

fig, axs = plt.subplots(2, 2, figsize=(12, 10))
fig.suptitle('Evaluasi Sistem Rekomendasi')

# Artist Diversity
axs[0, 0].bar(evaluation_results['track'], evaluation_results['artist_diversity'])
axs[0, 0].set_title('Artist Diversity')
axs[0, 0].set_ylabel('Score (0-1)')
axs[0, 0].tick_params(axis='x', rotation=45)

# Genre Diversity
axs[0, 1].bar(evaluation_results['track'], evaluation_results['genre_diversity'])
axs[0, 1].set_title('Genre Diversity')
axs[0, 1].set_ylabel('Score (0-1)')
axs[0, 1].tick_params(axis='x', rotation=45)

# Average Popularity
axs[1, 0].bar(evaluation_results['track'], evaluation_results['avg_popularity'])
axs[1, 0].set_title('Average Popularity')
axs[1, 0].set_ylabel('Score (0-100)')
axs[1, 0].tick_params(axis='x', rotation=45)

# Average Similarity
axs[1, 1].bar(evaluation_results['track'], evaluation_results['avg_similarity'])
axs[1, 1].set_title('Average Similarity')
axs[1, 1].set_ylabel('Score (0-1)')
axs[1, 1].tick_params(axis='x', rotation=45)

plt.tight_layout()
plt.show()

"""## Analisis Hasil Evaluasi Sistem Rekomendasi Musik

Hasil evaluasi menunjukkan kinerja sistem rekomendasi musik berbasis content-based filtering untuk empat lagu populer. Berikut analisisnya:

### 1. Artist Diversity (Keberagaman Artis)
- **Nilai rata-rata: 0.25 (skala 0-1)**
- Nilai ini cukup rendah, menunjukkan sistem cenderung merekomendasikan lagu dari artis yang sama
- 3 dari 4 lagu ("Shape of You", "Billie Jean", "Watermelon Sugar") memiliki nilai 0.2, artinya hanya 20% artis yang unik
- "Bad Guy" memiliki keberagaman artis lebih tinggi (0.4), menandakan variasi artis yang lebih baik

### 2. Genre Diversity (Keberagaman Genre)
- **Nilai rata-rata: 0.21 (skala 0-1)**
- Nilai ini rendah, mengindikasikan rekomendasi terbatas pada genre yang sangat mirip
- "Bad Guy" menunjukkan diversitas genre tertinggi (0.25)
- Lagu lainnya memiliki nilai 0.20, menandakan kurangnya variasi genre

### 3. Average Popularity (Rata-rata Popularitas)
- **Nilai rata-rata: 50.90 (skala 0-100)**
- "Billie Jean" mendapatkan rekomendasi lagu-lagu paling populer (69.8)
- "Shape of You" justru mendapat rekomendasi lagu-lagu kurang populer (28.6)
- Menunjukkan sistem tidak selalu mengutamakan lagu populer, tetapi lebih fokus pada kesamaan karakteristik

### 4. Average Similarity (Rata-rata Kesamaan)
- **Nilai rata-rata: 0.94 (skala 0-1)**
- Nilai sangat tinggi, menunjukkan rekomendasi sangat relevan dari segi kemiripan konten
- "Billie Jean" memiliki tingkat kemiripan tertinggi (0.988), hampir sempurna
- Semua lagu mendapatkan rekomendasi dengan nilai kesamaan di atas 0.9, mengindikasikan sistem sangat baik dalam mengidentifikasi lagu-lagu yang mirip

### Kesimpulan
Sistem rekomendasi sangat kuat dalam memberikan rekomendasi yang relevan (similarity tinggi) tetapi kurang dalam keberagaman (diversity rendah). Ini merupakan trade-off klasik dalam sistem rekomendasi content-based, di mana relevansi tinggi sering berarti keberagaman rendah. Untuk peningkatan, dapat dipertimbangkan teknik hybrid yang menggabungkan content-based dengan collaborative filtering atau menambahkan faktor randomisasi tertentu untuk meningkatkan keberagaman rekomendasi.
"""